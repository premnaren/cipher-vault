<!DOCTYPE html>
<html lang="en" data-theme="void">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cipher Chat | Secure Channel</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;900&family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Inter:wght@400;600&display=swap');

        :root {
            --bg-body: #050508;
            --bg-panel: #0f1015;
            --primary: #00f3ff;
            --accent: #bc13fe;
            --text-main: #e2e8f0;
            --border: #1e293b;
            --glow: 0 0 20px rgba(0, 243, 255, 0.1);
        }

        body {
            background-color: var(--bg-body);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            background-image: radial-gradient(var(--border) 1px, transparent 1px);
            background-size: 30px 30px;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .mono { font-family: 'Space Mono', monospace; }
        .orbitron { font-family: 'Orbitron', sans-serif; }

        /* SCROLLBAR */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--primary); }

        /* ANIMATIONS */
        .message-in { animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .user-item.active {
            background: rgba(0, 243, 255, 0.1);
            border-left: 3px solid var(--primary);
        }
        
        .encrypted-text {
            color: var(--accent);
            font-family: 'Space Mono', monospace;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

    <nav class="h-16 border-b border-[var(--border)] bg-[var(--bg-panel)] flex items-center justify-between px-6 z-20">
        <div class="flex items-center gap-4">
            <a href="/" class="text-xs font-bold text-gray-500 hover:text-white transition-colors flex items-center gap-2">
                <span>‚Üê</span> BACK TO VAULT
            </a>
            <div class="h-6 w-px bg-[var(--border)]"></div>
            <h1 class="orbitron text-xl font-bold tracking-widest text-[var(--primary)]">CIPHER <span class="text-white">CHAT</span></h1>
        </div>
        <div class="text-xs mono text-gray-500" id="currentUserDisplay">CONNECTING...</div>
    </nav>

    <div class="flex flex-1 overflow-hidden">
        
        <aside class="w-72 border-r border-[var(--border)] bg-[var(--bg-panel)] flex flex-col z-10">
            <div class="p-4 pb-2 border-b border-[var(--border)] space-y-3">
                <h2 class="text-xs font-bold text-gray-500 uppercase tracking-widest mb-1">Active Agents</h2>
                
                <div class="relative group">
                    <span class="absolute left-3 top-2.5 text-gray-500 text-xs">üîç</span>
                    <input type="text" id="userSearch" placeholder="SEARCH AGENT ID..." 
                        class="w-full bg-black border border-[var(--border)] text-xs text-white rounded pl-8 pr-3 py-2 outline-none font-mono focus:border-[var(--primary)] focus:shadow-[0_0_10px_rgba(0,243,255,0.2)] transition-all uppercase placeholder-gray-700">
                </div>

                <div class="text-[9px] text-[var(--primary)] animate-pulse pt-1">‚óè ENCRYPTED LINK ESTABLISHED</div>
            </div>

            <div id="usersList" class="flex-1 overflow-y-auto p-2 space-y-1">
                <div class="text-center text-xs text-gray-600 mt-10 mono">SCANNING NETWORK...</div>
            </div>
        </aside>

        <main class="flex-1 flex flex-col relative bg-black/20">
            
            <div id="chatHeader" class="h-14 border-b border-[var(--border)] flex items-center px-6 justify-between bg-[var(--bg-body)]/50 backdrop-blur hidden">
                <div class="flex items-center gap-3">
                    <div class="w-2 h-2 rounded-full bg-[var(--primary)] shadow-[0_0_10px_var(--primary)]"></div>
                    <div>
                        <div class="text-sm font-bold text-white orbitron tracking-wide" id="chatPartnerName">Select a User</div>
                        <div class="text-[10px] mono text-gray-500">SECURE CHANNEL ACTIVE</div>
                    </div>
                </div>
            </div>

            <div id="emptyState" class="absolute inset-0 flex flex-col items-center justify-center text-gray-600">
                <div class="text-4xl mb-4 opacity-20">üì°</div>
                <p class="mono text-xs tracking-widest">SELECT AN AGENT TO INITIALIZE UPLINK</p>
            </div>

            <div id="messagesArea" class="flex-1 overflow-y-auto p-6 space-y-4 hidden scroll-smooth">
            </div>

            <div id="inputArea" class="p-4 border-t border-[var(--border)] bg-[var(--bg-panel)] hidden">
                <div class="flex gap-2 mb-2 items-center">
                    <span class="text-[10px] text-gray-500 font-bold mono">ENCRYPTION PROTOCOL:</span>
                   <select id="cipherSelect" aria-label="Encryption Protocol" class="bg-black border border-[var(--border)] text-[10px] text-[var(--primary)] rounded px-2 py-1 outline-none font-mono focus:border-[var(--primary)] cursor-pointer">
                         <option value="none">OFF (PLAIN)</option>
                         <option value="caesar">CAESAR CIPHER</option>
                         <option value="vigenere">VIGEN√àRE CIPHER</option>
                         <option value="rsa">üîí RSA (MILITARY GRADE)</option>
                     </select>
                    <input type="text" id="cipherKey" placeholder="KEY (e.g. 3)" class="bg-black border border-[var(--border)] text-[10px] text-white rounded px-2 py-1 w-24 outline-none font-mono focus:border-[var(--primary)]">
                    
                    <label class="flex items-center gap-1 cursor-pointer ml-4 border border-red-900/50 bg-red-900/10 px-2 py-1 rounded hover:bg-red-900/30 transition-colors">
                        <input type="checkbox" id="burnCheck" class="accent-red-500">
                        <span class="text-[10px] text-red-500 font-bold mono">üî• BURN-ON-READ</span>
                    </label>
                </div>
                
                <form id="chatForm" class="flex gap-2">
                    <input type="text" id="msgInput" autocomplete="off" placeholder="Type a secure message..." 
                           class="flex-1 bg-black border border-[var(--border)] text-sm text-white rounded p-3 outline-none focus:border-[var(--primary)] transition-colors font-mono placeholder-gray-700">
                    <button type="submit" class="bg-[var(--primary)] text-black font-bold px-6 rounded hover:bg-[var(--accent)] hover:text-white transition-all orbitron tracking-wider text-sm shadow-[0_0_15px_rgba(0,243,255,0.2)]">
                        SEND
                    </button>
                </form>
            </div>
        </main>
    </div>

    <script>
        // --- 1. CONFIG & AUTH ---
        const token = localStorage.getItem('auth-token');
        if (!token) window.location.href = '/login.html';

        function parseJwt(token) {
            try { return JSON.parse(atob(token.split('.')[1])); } catch (e) { return null; }
        }

        const decoded = parseJwt(token);
        const userData = decoded.user || decoded; 
        const myId = userData._id || userData.id || userData.userId;
        const myName = userData.username || userData.name || "Agent";

        document.getElementById('currentUserDisplay').innerText = `ID: ${myName}`;

        const socket = io();
        socket.emit("login", myId);

        // --- 2. CRYPTO ENGINE (RSA) ---
        let myKeyPair = null;
        let partnerPublicKeys = {}; // Stores other users' locks

        async function initCrypto() {
            try {
                // Check if we already have keys in storage
                const storedPriv = localStorage.getItem('rsa-priv');
                const storedPub = localStorage.getItem('rsa-pub');

                if (storedPriv && storedPub) {
                    // Import existing keys
                    const privKey = await window.crypto.subtle.importKey(
                        "jwk", JSON.parse(storedPriv), 
                        { name: "RSA-OAEP", hash: "SHA-256" }, true, ["decrypt"]
                    );
                    const pubKey = await window.crypto.subtle.importKey(
                        "jwk", JSON.parse(storedPub), 
                        { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]
                    );
                    myKeyPair = { privateKey: privKey, publicKey: pubKey };
                } else {
                    // Generate NEW Keys
                    myKeyPair = await window.crypto.subtle.generateKey(
                        { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
                        true, ["encrypt", "decrypt"]
                    );
                    // Export and Save
                    const expPriv = await window.crypto.subtle.exportKey("jwk", myKeyPair.privateKey);
                    const expPub = await window.crypto.subtle.exportKey("jwk", myKeyPair.publicKey);
                    localStorage.setItem('rsa-priv', JSON.stringify(expPriv));
                    localStorage.setItem('rsa-pub', JSON.stringify(expPub));
                }

                // Upload Public Key to Server so others can text me
                const exportedPub = await window.crypto.subtle.exportKey("jwk", myKeyPair.publicKey);
                await fetch('/api/users/key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ userId: myId, publicKey: JSON.stringify(exportedPub) })
                });
                console.log("üîê CRYPTO SYSTEM ONLINE: Keys Loaded & Uploaded");
            } catch (e) {
                console.error("Crypto Init Failed:", e);
            }
        }
        initCrypto(); // Start Engine

        // --- 3. HELPER ALGORITHMS ---
        async function encryptRSA(text, pubKeyJson) {
            try {
                // Import partner's public key
                const pubKey = await window.crypto.subtle.importKey(
                    "jwk", JSON.parse(pubKeyJson), 
                    { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]
                );
                const enc = new TextEncoder();
                const encoded = enc.encode(text);
                const encrypted = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, pubKey, encoded);
                
                // Convert to Base64 to send via text
                return btoa(String.fromCharCode(...new Uint8Array(encrypted)));
            } catch (e) { console.error("Encrypt Error", e); return "[ENCRYPTION FAILED]"; }
        }

        async function decryptRSA(cipherText) {
            try {
                // Decode Base64
                const binaryString = atob(cipherText);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);

                const decrypted = await window.crypto.subtle.decrypt(
                    { name: "RSA-OAEP" }, myKeyPair.privateKey, bytes
                );
                const dec = new TextDecoder();
                return dec.decode(decrypted);
            } catch (e) { console.error("Decrypt Error", e); return "[DECRYPTION FAILED - WRONG KEY]"; }
        }

        const Algorithms = {
            caesar: (t, k, m) => { 
                const s = parseInt(k) || 0; const shift = m === 'encrypt' ? s : -s; 
                return t.replace(/[a-zA-Z]/g, c => { 
                    const b = c >= 'a' ? 97 : 65; 
                    return String.fromCharCode(((c.charCodeAt(0) - b + shift) % 26 + 26) % 26 + b); 
                }); 
            },
            vigenere: (t, k, m) => { 
                const key = k.toUpperCase().replace(/[^A-Z]/g,'') || 'A'; let ki = 0; 
                return t.replace(/[a-zA-Z]/g, c => { 
                    const b = c >= 'a' ? 97 : 65; 
                    const charCode = c.toUpperCase().charCodeAt(0) - 65; 
                    const keyCode = key[ki++ % key.length].charCodeAt(0) - 65; 
                    let result = m === 'encrypt' ? (charCode + keyCode) % 26 : (charCode - keyCode + 26) % 26; 
                    return String.fromCharCode(result + b); 
                }); 
            }
        };

        // --- 4. APP LOGIC ---
        let currentReceiver = null;
        const messagesArea = document.getElementById('messagesArea');

        async function fetchUsers() {
            try {
                const res = await fetch('/api/users');
                const users = await res.json();
                document.getElementById('usersList').innerHTML = '';
                
                users.forEach(user => {
                    if (user._id === myId) return;
                    
                    // STORE PUBLIC KEY
                    if(user.publicKey) partnerPublicKeys[user._id] = user.publicKey;

                    const div = document.createElement('div');
                    div.className = 'user-card user-item p-3 cursor-pointer hover:bg-white/5 transition-colors flex items-center gap-3 border-l-2 border-transparent';
                    div.setAttribute('data-name', user.username.toLowerCase());
                    div.setAttribute('data-id', user._id); 
                    
                    div.innerHTML = `
                        <div class="w-8 h-8 rounded bg-gray-800 flex items-center justify-center text-[var(--primary)] font-bold text-xs orbitron shadow-[0_0_5px_rgba(0,0,0,0.5)]">
                            ${user.username.substring(0,2).toUpperCase()}
                        </div>
                        <div>
                            <div class="text-sm font-bold text-gray-300 username-text">${user.username}</div>
                            <div class="text-[9px] text-gray-600 mono status-text">OFFLINE</div>
                        </div>
                    `;
                    div.onclick = () => selectUser(user, div);
                    document.getElementById('usersList').appendChild(div);
                });
            } catch (e) { console.error(e); }
        }
        fetchUsers();

        // Search Filter
        document.getElementById('userSearch').addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            document.querySelectorAll('.user-card').forEach(card => {
                const name = card.getAttribute('data-name');
                card.classList.toggle('hidden', !name.includes(term));
            });
        });

        function selectUser(user, element) {
            currentReceiver = user;
            document.querySelectorAll('.user-item').forEach(el => el.classList.remove('active'));
            element.classList.add('active');
            
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('chatHeader').classList.remove('hidden');
            document.getElementById('messagesArea').classList.remove('hidden');
            document.getElementById('inputArea').classList.remove('hidden');
            document.getElementById('chatPartnerName').innerText = user.username;

            socket.emit("join_room", { senderId: myId, receiverId: user._id });
            loadHistory(user._id);
            document.getElementById('msgInput').focus();
        }

        async function loadHistory(partnerId) {
            messagesArea.innerHTML = '<div class="text-center text-xs text-gray-600 mt-4 animate-pulse">DECRYPTING ARCHIVES...</div>';
            try {
                const res = await fetch(`/api/messages/${myId}/${partnerId}`);
                const msgs = await res.json();
                messagesArea.innerHTML = '';
                msgs.forEach(displayMessage);
                scrollToBottom();
            } catch (e) { console.error(e); }
        }

        // --- SEND MESSAGE (Now Async for RSA) ---
        document.getElementById('chatForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const input = document.getElementById('msgInput');
            const cipherType = document.getElementById('cipherSelect').value;
            const key = document.getElementById('cipherKey').value;
            const isBurn = document.getElementById('burnCheck').checked;
            let text = input.value;
            
            if (!text.trim() || !currentReceiver) return;

            // ENCRYPTION LOGIC
            let cipherText = text;
            if (cipherType === 'rsa') {
                const partnerKey = partnerPublicKeys[currentReceiver._id];
                if (!partnerKey) {
                    alert("ERROR: This agent hasn't established a secure key yet. Tell them to login again!");
                    return;
                }
                cipherText = await encryptRSA(text, partnerKey);
            } 
            else if (cipherType !== 'none' && Algorithms[cipherType]) {
                cipherText = Algorithms[cipherType](text, key, 'encrypt');
            }

            const messageData = {
                senderId: myId,
                receiverId: currentReceiver._id,
                text: cipherText, 
                cipherType: cipherType,
                isBurn: isBurn,
                timestamp: new Date()
            };

            socket.emit("private_message", messageData);

            displayMessage({
                sender: myId,
                text: cipherText, // Show encrypted version
                cipherType: cipherType,
                isBurn: isBurn,
                isSelf: true,
                originalText: text // Pass original so I can see what I wrote
            });

            input.value = '';
            document.getElementById('burnCheck').checked = false;
            scrollToBottom();
        });

        // --- RECEIVE MESSAGE ---
        socket.on("receive_message", (data) => {
            if (currentReceiver && (data.senderId === currentReceiver._id || data.sender === currentReceiver._id)) {
                displayMessage({
                    sender: data.senderId || data.sender, 
                    text: data.text,
                    cipherType: data.cipherType,
                    isBurn: data.isBurn, // Pass burn flag
                    isSelf: false,
                    _id: data._id
                });
                scrollToBottom();
            }
        });

        socket.on("message_burnt", (msgId) => {
            const msgDiv = document.getElementById(`msg-${msgId}`);
            if (msgDiv) {
                msgDiv.style.transition = "all 0.5s ease";
                msgDiv.style.opacity = "0";
                msgDiv.style.transform = "scale(0.9)";
                msgDiv.innerHTML = '<div class="text-red-500 font-mono text-xs text-center">üí• MESSAGE SELF-DESTRUCTED üí•</div>';
                setTimeout(() => msgDiv.remove(), 2000);
            }
        });

        function displayMessage(msg) {
            if(messagesArea.innerHTML.includes('CHANNEL EMPTY')) messagesArea.innerHTML = '';
            const isMe = (msg.sender === myId || msg.isSelf);
            const div = document.createElement('div');
            
            // Set ID for Burn Logic
            if (msg._id) div.id = `msg-${msg._id}`; 

            div.className = `flex ${isMe ? 'justify-end' : 'justify-start'} message-in mb-4`;
            
            let contentHtml = '';
            
            // LOCK UI
            if (msg.cipherType && msg.cipherType !== 'none') {
                // If it's ME and I have the original text (for RSA), show it
                let displayText = (isMe && msg.originalText) ? msg.originalText : msg.text;
                let isEncrypted = true;

                // If I am the sender, I see plain text (optional, but good UX). 
                // If I am receiver, I see Cipher text until I unlock.
                if (isMe && msg.cipherType === 'rsa') isEncrypted = false; 

                contentHtml = `
                    <div class="mb-2 text-[9px] ${isMe ? 'text-right' : 'text-left'} text-gray-500 mono uppercase tracking-widest border-b border-white/10 pb-1">
                        üîí ${msg.cipherType.toUpperCase()}
                    </div>
                    <div class="${isEncrypted ? 'encrypted-text' : 'text-white'} break-all text-sm mb-2" id="text-${msg._id || Date.now()}">
                        ${displayText}
                    </div>
                    ${!isMe ? `<button onclick="attemptDecrypt(this, '${msg.text}', '${msg.cipherType}')" class="text-[10px] bg-white/5 hover:bg-[var(--primary)] hover:text-black border border-white/20 px-3 py-1.5 rounded transition-all mono w-full flex items-center justify-center gap-2 group"><span>UNLOCK DATA</span> <span class="group-hover:rotate-90 transition-transform">üîì</span></button>` : ''}
                `;
            } else {
                contentHtml = `<div class="break-all text-sm">${msg.text}</div>`;
            }

            div.innerHTML = `
                <div class="max-w-[75%] rounded-lg p-4 shadow-lg ${isMe ? 'bg-[var(--primary)] text-black font-bold' : 'bg-[#12141a] border border-[var(--border)] text-gray-300'}">
                    ${contentHtml}
                </div>
            `;
            messagesArea.appendChild(div);
        }

        // --- DECRYPT HANDLER ---
        window.attemptDecrypt = async (btn, cipherText, type) => {
            const textEl = btn.previousElementSibling;
            
            if (type === 'rsa') {
                textEl.innerText = "DECRYPTING WITH PRIVATE KEY...";
                const plainText = await decryptRSA(cipherText);
                textEl.innerText = plainText;
            } 
            else {
                // Classic Ciphers
                const key = prompt(`ENTER DECRYPTION KEY FOR [${type.toUpperCase()}]:`);
                if (!key) return;
                if (Algorithms[type]) {
                    const plainText = Algorithms[type](cipherText, key, 'decrypt');
                    textEl.innerText = plainText;
                }
            }
            
            textEl.classList.remove('encrypted-text');
            textEl.classList.add('text-green-400', 'font-bold', 'mono'); 
            btn.remove();
        };

        function scrollToBottom() { messagesArea.scrollTop = messagesArea.scrollHeight; }

        // --- ONLINE STATUS ---
        socket.on("get_users", (onlineUserIds) => {
            document.querySelectorAll('.user-card').forEach(card => {
                const userId = card.getAttribute('data-id'); 
                const statusText = card.querySelector('.status-text');
                if (onlineUserIds.includes(userId)) {
                    statusText.innerText = "ONLINE";
                    statusText.classList.remove('text-gray-600');
                    statusText.classList.add('text-[var(--primary)]', 'animate-pulse'); 
                    card.classList.add('border-[var(--primary)]');
                    card.classList.remove('border-transparent');
                } else {
                    statusText.innerText = "OFFLINE";
                    statusText.classList.add('text-gray-600');
                    statusText.classList.remove('text-[var(--primary)]', 'animate-pulse');
                    card.classList.remove('border-[var(--primary)]');
                    card.classList.add('border-transparent');
                }
            });
        });
    </script>
</body>
</html>